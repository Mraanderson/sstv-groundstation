{% extends "base.html" %}
{% block title %}Diagnostics{% endblock %}
{% block content %}

{% with messages = get_flashed_messages(with_categories=true) %}
  {% if messages %}
    <div class="flashes">
      {% for category, message in messages %}
        <div class="alert alert-{{ category }}" role="alert">{{ message }}</div>
      {% endfor %}
    </div>
  {% endif %}
{% endwith %}

<h1>RTL‚ÄëSDR Diagnostics</h1>
<p>Check dongle presence, calibrate PPM, and run manual recordings.</p>

<hr>
<h2>Dongle / Software Presence</h2>
<p>
  <span id="swBadge" class="badge bg-secondary">Checking software‚Ä¶</span>
  <span id="hwBadge" class="badge bg-secondary">Checking hardware‚Ä¶</span>
</p>
<pre id="outputBox" class="mt-3"></pre>

<hr>
<h2>System Status</h2>
<p id="diskInfo">Disk free: ‚Ä¶</p>
<ul id="orphanList"><li>Loading orphan IQ info‚Ä¶</li></ul>

<hr>
<h2>SDR Traffic‚ÄëLight Status</h2>
<span id="sdrLight" class="badge bg-secondary">Checking‚Ä¶</span>

<hr>
<h2>Calibration</h2>
<div id="ppmBox" class="alert alert-secondary">
  Current PPM correction: <span id="ppmValue">{{ ppm }}</span>
</div>
<button id="calibrateBtn" class="btn btn-warning">üõ†Ô∏è Calibrate SDR</button>
<button id="resetPpmBtn" class="btn btn-outline-danger ms-2">Reset PPM</button>
<div id="calibrationResult" class="mt-3"></div>

<hr>
<h2>Manual Recorder</h2>
<form method="post" action="{{ url_for('diagnostics.manual_recorder') }}" class="row g-3 align-items-end mb-4">
  <div class="col-md-3">
    <label for="frequency" class="form-label">Frequency</label>
    <input type="text" class="form-control" id="frequency" name="frequency" value="145.800M" required>
  </div>
  <div class="col-md-2">
    <label for="duration" class="form-label">Duration (s)</label>
    <input type="number" class="form-control" id="duration" name="duration" value="30" required>
  </div>
  <div class="col-md-2">
    <label class="form-label">PPM</label>
    <div class="form-control-plaintext text-muted">Auto-set to 0</div>
  </div>
  <div class="col-md-3">
    <label for="gain" class="form-label">Gain</label>
    <select class="form-select" id="gain" name="gain">
      <option value="0" {% if gain=="0" %}selected{% endif %}>0 (AGC)</option>
      {% for g in ["0.9","4.0","7.7","11.6","14.4","15.7","16.6","19.7","20.7","22.9","25.4","28.0","29.7","32.8","33.8","36.4","37.2","38.6","40.2","42.1","43.4","43.9","44.5","48.0","49.6"] %}
        <option value="{{ g }}" {% if gain==g %}selected{% endif %}>{{ g }} dB</option>
      {% endfor %}
    </select>
  </div>
  <div class="col-md-2">
    <button type="submit" class="btn btn-primary w-100">Start Record</button>
  </div>
</form>

<h4>Manual Recordings History</h4>
<ul class="list-group">
  {% for entry in files %}
    <li class="list-group-item {% if loop.first %}list-group-item-info{% endif %}">
      <strong>{{ entry.wav }}</strong>
      {% if entry.meta %}
        {% if entry.meta.gain %}
          <span class="badge bg-info">Gain {{ entry.meta.gain }}</span>
        {% endif %}
        {% if entry.meta.ppm %}
          <span class="badge bg-secondary">PPM {{ entry.meta.ppm }}</span>
        {% endif %}
        {% if entry.meta.frequency %}
          <span class="badge bg-light text-dark">Freq {{ entry.meta.frequency }}</span>
        {% endif %}
      {% endif %}
      <div class="btn-group float-end">
        {% if entry.wav %}
          <a href="{{ url_for('recordings.recordings_file', filename='manual/' + entry.wav) }}" class="btn btn-sm btn-outline-secondary">WAV</a>
        {% endif %}
        {% if entry.log %}
          <a href="{{ url_for('recordings.recordings_file', filename='manual/' + entry.log) }}" class="btn btn-sm btn-outline-secondary">Log</a>
        {% endif %}
        {% if entry.png %}
          <a href="{{ url_for('recordings.recordings_file', filename='manual/' + entry.png) }}" class="btn btn-sm btn-outline-success">SSTV</a>
        {% endif %}
      </div>
    </li>
  {% else %}
    <li class="list-group-item">No manual recordings found.</li>
  {% endfor %}
            </ul>
            <script>
async function runDongleCheck() {
  try {
    const res = await fetch("{{ url_for('diagnostics.diagnostics_check') }}");
    const data = await res.json();
    const swBadge = document.getElementById("swBadge");
    const hwBadge = document.getElementById("hwBadge");
    const output = document.getElementById("outputBox");

    swBadge.textContent = data.software ? "Software Installed" : "Software Missing";
    swBadge.className = data.software ? "badge bg-success" : "badge bg-danger";

    hwBadge.textContent = data.hardware ? "Dongle Detected" : "No Dongle";
    hwBadge.className = data.hardware ? "badge bg-success" : "badge bg-danger";

    if (data.output) output.textContent = data.output;
  } catch (err) {
    document.getElementById("swBadge").textContent = "Error";
    document.getElementById("hwBadge").textContent = "Error";
    document.getElementById("outputBox").textContent = String(err);
  }
}

async function updateStatus() {
  try {
    const res = await fetch("{{ url_for('diagnostics.diagnostics_status') }}");
    const data = await res.json();

    document.getElementById("diskInfo").innerText = "Disk free: " + data.disk_free_gb + " GB";

    const list = document.getElementById("orphanList");
    list.innerHTML = "";
    if (data.orphan_iq?.length) {
      data.orphan_iq.forEach(file => {
        const li = document.createElement("li");
        let text = file.path + " (" + file.size_mb + " MB)";
        if (file.deleted) text += " ‚Äî auto‚Äëdeleted (stale)";
        if (file.delete_error) text += " ‚Äî error: " + file.delete_error;
        li.textContent = text;
        list.appendChild(li);
      });
    } else {
      list.innerHTML = "<li>No orphan files</li>";
    }

    const ppmBox = document.getElementById("ppmBox");
    const ppmValue = document.getElementById("ppmValue");
    if (data.rtl_ppm !== undefined) {
      ppmValue.textContent = data.rtl_ppm + " ppm";
      if (parseInt(data.rtl_ppm) === 0) {
        ppmBox.className = "alert alert-warning";
        ppmBox.innerHTML = "‚ö†Ô∏è No calibration value found (using 0 ppm). Please run calibration.";
      }
    } else {
      ppmValue.textContent = "not available";
    }
  } catch (err) {
    document.getElementById("diskInfo").innerText = "Disk free: error";
    document.getElementById("orphanList").innerHTML = "<li>Error loading orphan files</li>";
  }
}

async function updateSdrLight() {
  try {
    const res = await fetch("{{ url_for('diagnostics.sdr_status') }}");
    const data = await res.json();
    const el = document.getElementById("sdrLight");
    const map = {
      green: {cls: "badge bg-success", text: "üü¢ Ready"},
      red:   {cls: "badge bg-danger",  text: "üî¥ In Use"},
      amber: {cls: "badge bg-warning text-dark", text: "üü† Scheduled Soon"},
      grey:  {cls: "badge bg-secondary", text: "‚ö™ Not Present"}
    };
    const st = map[data.status] || map.grey;
    el.className = st.cls;
    el.textContent = st.text;
  } catch (err) {
    const el = document.getElementById("sdrLight");
    el.className = "badge bg-warning text-dark";
    el.textContent = "Error";
  }
}

document.getElementById("calibrateBtn").addEventListener("click", async function() {
  this.disabled = true;
  this.textContent = "Calibrating...";
  const resultBox = document.getElementById("calibrationResult");
  resultBox.innerHTML = "";
  try {
    const res = await fetch("{{ url_for('diagnostics.calibrate') }}", {method: "POST"});
    const data = await res.json();
    if (data.success) {
      resultBox.innerHTML = `
        <div class="alert alert-success">
          <strong>PPM correction:</strong> ${data.ppm}<br>
          <strong>Measured:</strong> ${data.measured_hz} Hz<br>
          <strong>Expected:</strong> ${data.expected_hz} Hz<br>
          <strong>Timestamp:</strong> ${data.timestamp}
        </div>
        <div class="row">
          <div class="col-md-6">
            <h6>Before</h6>

<script>
async function runDongleCheck() {
  try {
    const res = await fetch("{{ url_for('diagnostics.diagnostics_check') }}");
    const data = await res.json();
    const swBadge = document.getElementById("swBadge");
    const hwBadge = document.getElementById("hwBadge");
    const output = document.getElementById("outputBox");

    swBadge.textContent = data.software ? "Software Installed" : "Software Missing";
    swBadge.className = data.software ? "badge bg-success" : "badge bg-danger";

    hwBadge.textContent = data.hardware ? "Dongle Detected" : "No Dongle";
    hwBadge.className = data.hardware ? "badge bg-success" : "badge bg-danger";

    if (data.output) output.textContent = data.output;
  } catch (err) {
    document.getElementById("swBadge").textContent = "Error";
    document.getElementById("hwBadge").textContent = "Error";
    document.getElementById("outputBox").textContent = String(err);
  }
}

async function updateStatus() {
  try {
    const res = await fetch("{{ url_for('diagnostics.diagnostics_status') }}");
    const data = await res.json();

    const diskInfo = document.getElementById("diskInfo");
    if (typeof data.disk_free_gb === "number") {
      diskInfo.innerText = "Disk free: " + data.disk_free_gb + " GB";
    } else {
      diskInfo.innerText = "Disk free: unknown";
    }

    const list = document.getElementById("orphanList");
    list.innerHTML = "";
    if (data.orphan_iq?.length) {
      data.orphan_iq.forEach(file => {
        const li = document.createElement("li");
        let text = file.path + " (" + file.size_mb + " MB)";
        if (file.deleted) text += " ‚Äî auto‚Äëdeleted (stale)";
        if (file.delete_error) text += " ‚Äî error: " + file.delete_error;
        li.textContent = text;
        list.appendChild(li);
      });
    } else {
      list.innerHTML = "<li>No orphan files</li>";
    }

    const ppmBox = document.getElementById("ppmBox");
    const ppmValue = document.getElementById("ppmValue");
    if (data.rtl_ppm !== undefined) {
      ppmValue.textContent = data.rtl_ppm + " ppm";
      if (parseInt(data.rtl_ppm) === 0) {
        ppmBox.className = "alert alert-warning";
        ppmBox.innerHTML = "‚ö†Ô∏è No calibration value found (using 0 ppm). Please run calibration.";
      }
    } else {
      ppmValue.textContent = "not available";
    }
  } catch (err) {
    document.getElementById("diskInfo").innerText = "Disk free: error";
    document.getElementById("orphanList").innerHTML = "<li>Error loading orphan files</li>";
  }
}

async function updateSdrLight() {
  try {
    const res = await fetch("{{ url_for('diagnostics.sdr_status') }}");
    const data = await res.json();
    const el = document.getElementById("sdrLight");
    const map = {
      green: {cls: "badge bg-success", text: "üü¢ Ready"},
      red:   {cls: "badge bg-danger",  text: "üî¥ In Use"},
      amber: {cls: "badge bg-warning text-dark", text: "üü† Scheduled Soon"},
      grey:  {cls: "badge bg-secondary", text: "‚ö™ Not Present"}
    };
    const st = map[data.status] || map.grey;
    el.className = st.cls;
    el.textContent = st.text;
  } catch (err) {
    const el = document.getElementById("sdrLight");
    el.className = "badge bg-warning text-dark";
    el.textContent = "Error";
  }
}

document.getElementById("calibrateBtn").addEventListener("click", async function() {
  this.disabled = true;
  this.textContent = "Calibrating...";
  const resultBox = document.getElementById("calibrationResult");
  resultBox.innerHTML = "";
  try {
    const res = await fetch("{{ url_for('diagnostics.calibrate') }}", {method: "POST"});
    const data = await res.json();
    if (data.success) {
      resultBox.innerHTML = `
        <div class="alert alert-success">
          <strong>PPM correction:</strong> ${data.ppm}<br>
          <strong>Measured:</strong> ${data.measured_hz} Hz<br>
          <strong>Expected:</strong> ${data.expected_hz} Hz<br>
          <strong>Timestamp:</strong> ${data.timestamp}
        </div>
        <div class="row">
          <div class="col-md-6">
            <h6>Before</h6>
            <img src="/gallery/gallery/image/${data.png_before}" class="img-fluid border rounded" alt="Before calibration">
          </div>
          <div class="col-md-6">
            <h6>After</h6>
            <img src="/gallery/gallery/image/${data.png_after}" class="img-fluid border rounded" alt="After calibration">
          </div>
        </div>
        <h6 class="mt-3">CSV Preview</h6>
        <pre class="bg-light p-2 border rounded">${data.csv_preview.join('\n')}</pre>`;
    } else {
      resultBox.innerHTML = `<div class="alert alert-danger">Calibration failed: ${data.error}</div>`;
    }
  } catch (err) {
    resultBox.innerHTML = `<div class="alert alert-warning">Error: ${String(err)}</div>`;
  }
  this.disabled = false;
  this.textContent = "üõ†Ô∏è Calibrate SDR";
  updateStatus();
});

document.getElementById("resetPpmBtn").addEventListener("click", async function() {
  this.disabled = true;
  try {
    const res = await fetch("{{ url_for('diagnostics.reset_ppm_route') }}", {method: "POST"});
    const data = await res.json();
    if (data.success) {
      document.getElementById("ppmValue").textContent = "0 ppm";
      alert("PPM reset to 0.");
    } else {
      alert("Reset failed: " + data.error);
    }
  } catch (err) {
    alert("Error resetting PPM: " + err);
  }
  this.disabled = false;
});

document.addEventListener("DOMContentLoaded", () => {
  runDongleCheck();
  updateStatus();
  updateSdrLight();
  setInterval(updateStatus, 5000);
  setInterval(updateSdrLight, 5000);
});
</script>
{% endblock %}
