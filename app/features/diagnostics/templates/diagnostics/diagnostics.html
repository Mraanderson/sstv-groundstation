{% extends "base.html" %}
{% block title %}Diagnostics{% endblock %}
{% block content %}
<h1>RTL‚ÄëSDR Diagnostics</h1>

<p>
This page helps you check that your RTL‚ÄëSDR dongle is connected, working correctly, and properly calibrated. 
Each section below runs a different test or maintenance task and explains why it matters.
</p>

<hr>

<h2>Dongle Presence Check</h2>
<p>
This test runs <code>rtl_test</code> briefly to confirm that the SDR hardware is detected by the system 
and can stream samples.
</p>
<span id="statusBadge" class="badge bg-secondary">Checking‚Ä¶</span>
<pre id="outputBox" class="mt-3"></pre>

<hr>

<h2>System Status</h2>
<p id="diskInfo">Disk free: ‚Ä¶</p>
<p id="passInfo">Pass status: ‚Ä¶</p>
<ul id="orphanList"><li>Loading‚Ä¶</li></ul>

<hr>

<h2>SDR Traffic‚ÄëLight Status</h2>
<p>
This indicator shows whether the SDR is present and available, busy with another process, 
reserved for a scheduled pass, or missing entirely.
</p>
<span id="sdrLight" class="badge bg-secondary">Checking‚Ä¶</span>

<hr>

<h2>Calibration</h2>
<p>
Calibration measures how far your dongle‚Äôs internal clock drifts from true frequency. 
It scans the FM broadcast band, finds a strong station, and compares the measured frequency 
to the expected channel. The result is a <strong>PPM correction number</strong>. 
This number is then applied automatically to all future recordings.
</p>
<div class="alert alert-info">
  Why calibrate? SDR dongles use inexpensive crystal oscillators that can drift by tens of kHz. 
  Calibration measures this error and applies a correction (PPM). Without it, narrowband signals 
  like satellites may be missed or distorted. 
  <a href="https://osmocom.org/projects/rtl-sdr/wiki/Rtl-sdr" target="_blank">Learn more</a>.
</div>

<div id="ppmBox" class="alert alert-secondary">
  Current PPM correction: <span id="ppmValue">loading‚Ä¶</span>
</div>

<button id="calibrateBtn" class="btn btn-warning">üõ†Ô∏è Calibrate SDR</button>
<div id="calibrationResult" class="mt-3"></div>

<hr>

<h2>Manual Recorder</h2>
<form method="post" action="{{ url_for('diagnostics.manual_recorder') }}">
  ...
</form>

<ul>
  {% for f in files %}
    ...
  {% endfor %}
</ul>


<script>
async function runDongleCheck() {
  try {
    const res = await fetch("{{ url_for('diagnostics.diagnostics_check') }}");
    const data = await res.json();
    const badge = document.getElementById("statusBadge");
    const output = document.getElementById("outputBox");
    if (data.success) {
      badge.textContent = "Dongle Present";
      badge.className = "badge bg-success";
    } else {
      badge.textContent = "Not Detected";
      badge.className = "badge bg-danger";
    }
    output.textContent = data.output;
  } catch (err) {
    const badge = document.getElementById("statusBadge");
    badge.textContent = "Error";
    badge.className = "badge bg-warning";
    document.getElementById("outputBox").textContent = err;
  }
}

async function updateStatus() {
  try {
    const res = await fetch("{{ url_for('diagnostics.diagnostics_status') }}");
    const data = await res.json();

    document.getElementById("diskInfo").innerText =
      "Disk free: " + data.disk_free_gb + " GB";

    if (data.pass_info) {
      let msg = "Pass in progress: " + data.pass_info.satellite +
                " (IQ: " + data.pass_info.iq_file + ")";
      if (data.pass_info.iq_size_mb !== undefined) {
        msg += " ‚Äî size: " + data.pass_info.iq_size_mb + " MB";
      }
      document.getElementById("passInfo").innerText = msg;
    } else {
      document.getElementById("passInfo").innerText = "No pass in progress";
    }

    const list = document.getElementById("orphanList");
    list.innerHTML = "";
    if (data.orphan_iq && data.orphan_iq.length > 0) {
      data.orphan_iq.forEach(file => {
        const li = document.createElement("li");
        let text = file.path + " (" + file.size_mb + " MB)";
        if (file.deleted) text += " ‚Äî auto‚Äëdeleted (low disk space)";
        if (file.delete_error) text += " ‚Äî error: " + file.delete_error;
        li.textContent = text;
        list.appendChild(li);
      });
    } else {
      list.innerHTML = "<li>No orphan IQ files</li>";
    }

    // Update PPM box
    const ppmBox = document.getElementById("ppmBox");
    const ppmValue = document.getElementById("ppmValue");
    if (data.rtl_ppm !== undefined) {
      ppmValue.textContent = data.rtl_ppm + " ppm";
      if (data.rtl_ppm === 0) {
        ppmBox.className = "alert alert-warning";
        ppmBox.innerHTML = "‚ö†Ô∏è No calibration value found (using 0 ppm). Please run calibration.";
      }
    } else {
      ppmValue.textContent = "not available";
    }
  } catch (err) {
    document.getElementById("diskInfo").innerText = "Disk free: error";
    document.getElementById("passInfo").innerText = "Pass status: error";
    document.getElementById("orphanList").innerHTML = "<li>Error loading orphan files</li>";
  }
}

async function updateSdrLight() {
  try {
    const res = await fetch("{{ url_for('diagnostics.sdr_status') }}");
    const data = await res.json();
    const el = document.getElementById("sdrLight");
    const map = {
      green: {cls: "badge bg-success", text: "üü¢ Ready"},
      red:   {cls: "badge bg-danger",  text: "üî¥ In Use"},
      amber: {cls: "badge bg-warning text-dark", text: "üü† Scheduled Soon"},
      grey:  {cls: "badge bg-secondary", text: "‚ö™ Not Present"}
    };
    const st = map[data.status] || map.grey;
    el.className = st.cls;
    el.textContent = st.text;
  } catch (err) {
    const el = document.getElementById("sdrLight");
    el.className = "badge bg-warning text-dark";
    el.textContent = "Error";
  }
}

document.getElementById("calibrateBtn").addEventListener("click", async function() {
  this.disabled = true;
  this.textContent = "Calibrating...";
  const resultBox = document.getElementById("calibrationResult");
  resultBox.innerHTML = "";
  try {
    const res = await fetch("{{ url_for('diagnostics.calibrate') }}", {method: "POST"});
    const data = await res.json();
    if (data.success) {
      resultBox.innerHTML = `
        <div class="alert alert-success">
          <strong>PPM correction:</strong> ${data.ppm}<br>
          <strong>Measured:</strong> ${data.measured_hz} Hz<br>
          <strong>Expected:</strong> ${data.expected_hz} Hz
        </div>
        <div class="row">
          <div class="col-md-6">
            <h6>Before</h6>
            <img src="/gallery/gallery/image/${data.png_before}" class="img-fluid border rounded">
          </div>
          <div class="col-md-6">
            <h6>After</h6>
            <img src="gallery/gallery/image/${data.png_after}" class="img-fluid border rounded">
          </div>
        </div>`;
    } else {
      resultBox.innerHTML = `<div class="alert alert-danger">Calibration failed: ${data.error}</div>`;
    }
  } catch (err) {
    resultBox.innerHTML = `<div class="alert alert-warning">Error: ${err}</div>`;
  }
  this.disabled = false;
  this.textContent = "üõ†Ô∏è Calibrate SDR";
});

// Run checks on load and poll status
runDongleCheck();
setInterval(updateStatus, 5000);
updateStatus();
setInterval(updateSdrLight, 5000);
updateSdrLight();
</script>
{% endblock %}
